[{"name":"RMI Remote Code Execution","description":"Questa vulnerabilità consente a un attaccante di eseguire codice arbitrario sul server tramite un attacco RMI.","severity":"seria","solution":"Per risolvere questa vulnerabilità, è necessario implementare meccanismi di sicurezza adeguati come l\u0027autenticazione e l\u0027autorizzazione per limitare l\u0027accesso alle funzionalità sensibili del server RMI.","exampleSolutionCode":"Implementare l\u0027autenticazione e l\u0027autorizzazione nel server RMI utilizzando ad esempio il framework Spring Security.","fileName":"Hello.java"},{"name":"RMI Registry Port Vulnerability","description":"La porta predefinita del registro RMI (1099) è vulnerabile agli attacchi di forza bruta e di scansione.","severity":"medio","solution":"Cambiare la porta predefinita del registro RMI per rendere più difficile agli attaccanti scoprire e sfruttare la vulnerabilità.","exampleSolutionCode":"LocateRegistry.createRegistry(1234);","fileName":"Server.java"},{"name":"HTTP Redirect Vulnerability","description":"Questa implementazione di HttpServiceImpl non segue i redirect HTTP quando si effettua una richiesta HTTP.","severity":"potenziale","solution":"Per mitigare questa vulnerabilità, è consigliabile seguire i redirect HTTP durante le richieste HTTP.","exampleSolutionCode":"restTemplate.setFollowRedirects(true);","fileName":"HttpServiceImpl.java"},{"name":"Utilizzo di una chiave segreta hardcoded","description":"La chiave segreta utilizzata per firmare il token JWT è hardcoded nel codice sorgente, rendendola facilmente accessibile agli attaccanti.","severity":"serio","solution":"Estrarre la chiave segreta da una sorgente esterna sicura, come un file di configurazione o una variabile di ambiente.","exampleSolutionCode":"private static final String SECRET \u003d System.getenv(\"JWT_SECRET\");","fileName":"JwtUtils.java"},{"name":"Cross-Site Scripting (XSS)","description":"La funzione json2Jsonp potrebbe essere vulnerabile a attacchi di Cross-Site Scripting (XSS) se i parametri callback e jsonStr non vengono opportunamente sanificati.","severity":"medium","solution":"Sanificare i parametri callback e jsonStr utilizzando una libreria o una funzione specifica per la codifica degli elementi HTML.","exampleSolutionCode":"return HtmlUtils.htmlEscape(callback) + \"(\" + HtmlUtils.htmlEscape(jsonStr) + \")\";","fileName":"WebUtils.java"},{"name":"HTTP Response Splitting","description":"L\u0027applicazione utilizza la classe HttpClient che non gestisce correttamente gli header HTTP, consentendo un potenziale attacco di HTTP Response Splitting.","severity":"serious","solution":"Utilizzare una libreria che gestisca correttamente gli header HTTP, come ad esempio Apache HttpComponents.","exampleSolutionCode":"CloseableHttpClient client \u003d HttpClients.createDefault();\nHttpGet httpGet \u003d new HttpGet(url);\nHttpResponse httpResponse \u003d client.execute(httpGet);","fileName":"HttpUtils.java"},{"name":"Injection di dipendenza non sicura","description":"La classe WebConfig utilizza l\u0027annotazione @Value per iniettare valori dalle proprietà dell\u0027applicazione. Tuttavia, non viene effettuato alcun controllo sulla sicurezza dei valori iniettati, aprendo la porta a possibili attacchi di injection di dipendenza.","severity":"medio","solution":"Per mitigare questa vulnerabilità, è consigliabile implementare controlli di sicurezza sui valori iniettati utilizzando metodi di validazione e sanitizzazione dei dati. Inoltre, è consigliabile utilizzare un meccanismo di iniezione di dipendenza sicuro, come ad esempio l\u0027uso di Spring Security.","exampleSolutionCode":"public void setJsonpReferCheckEnabled(Boolean jsonpReferCheckEnabled) {\n  if(jsonpReferCheckEnabled) {\n    WebConfig.jsonpReferCheckEnabled \u003d jsonpReferCheckEnabled;\n  }\n}","fileName":"WebConfig.java"},{"name":"Configurazione CORS non restrittiva","description":"La configurazione CORS non è restrittiva e consente richieste da qualsiasi origine e con qualsiasi metodo.","severity":"serio","solution":"Limitare le origini consentite e i metodi consentiti nella configurazione CORS.","exampleSolutionCode":"config.addAllowedOrigin(\"http://test.joychou.org\");\nconfig.addAllowedOrigin(\"https://test.joychou.org\");\nconfig.addAllowedMethod(\"GET\");\nconfig.addAllowedMethod(\"POST\");","fileName":"CorsConfig2.java"},{"name":"Utilizzo di AbstractJsonpResponseBodyAdvice","description":"L\u0027utilizzo di AbstractJsonpResponseBodyAdvice è deprecato e verrà rimosso a partire dalla versione 5.1 di Spring Framework. Si consiglia di utilizzare CORS al suo posto.","severity":"medium","solution":"Aggiornare il codice per utilizzare CORS invece di AbstractJsonpResponseBodyAdvice.","exampleSolutionCode":"import org.springframework.web.bind.annotation.CrossOrigin;\n\n@ControllerAdvice\npublic class Object2Jsonp {\n\n    @CrossOrigin\n    protected void beforeBodyWriteInternal(...) {\n        // codice per il corpo del metodo\n    }\n}","fileName":"Object2Jsonp.java"},{"name":"Configurazione CSRF non sicura","description":"La configurazione del token CSRF non è sicura perché il token viene inviato come cookie e può essere letto da JavaScript.","severity":"medio","solution":"Impostare il flag \u0027httpOnly\u0027 su \u0027true\u0027 per il cookie del token CSRF per impedire che sia letto da JavaScript.","exampleSolutionCode":"return CookieCsrfTokenRepository.withHttpOnlyTrue();","fileName":"CsrfTokenBean.java"},{"name":"Configuring Swagger to allow unrestricted access","description":"The code allows unrestricted access to the Swagger documentation, potentially exposing sensitive information.","severity":"serious","solution":"Restrict access to the Swagger documentation by adding authentication and authorization mechanisms.","exampleSolutionCode":"Add authentication and authorization mechanisms to the Swagger configuration, such as OAuth2 or API key authentication.","fileName":"SwaggerConfig.java"},{"name":"CORS Origin Whitelist Bypass","description":"Questa configurazione di CORS consente a qualsiasi dominio di inviare richieste al server, bypassando la whitelist degli origini consentiti.","severity":"serious","solution":"Limitare l\u0027elenco degli origini consentiti solo ai domini attendibili e necessari.","exampleSolutionCode":"String[] allowOrigins \u003d {\"https://www.example.com\", \"https://www.example2.com\"};\nregistry.addMapping(\"/cors/sec/webMvcConfigurer\")\n        .allowedOrigins(allowOrigins)\n        .allowedMethods(\"GET\", \"POST\")\n        .allowCredentials(true);","fileName":"CustomCorsConfig.java"},{"name":"XML External Entity (XXE) Injection","description":"Il codice legge un file XML esterno senza alcun controllo, consentendo un attacco di XXE.","severity":"serious","solution":"Utilizzare un parser XML sicuro che disabiliti l\u0027elaborazione delle entità esterne o applicare controlli per filtrare le entità esterne.","exampleSolutionCode":"DocumentBuilderFactory dbf \u003d DocumentBuilderFactory.newInstance();\n\n// Disabilita l\u0027elaborazione delle entità esterne\ndbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);","fileName":"SafeDomainParser.java"},{"name":"Configurazione di RestTemplate con followRedirects impostato su false","description":"La configurazione di RestTemplate con followRedirects impostato su false può consentire a un attaccante di eseguire attacchi di phishing o dirottare il traffico verso siti dannosi.","severity":"medio","solution":"Impostare followRedirects su true per consentire il reindirizzamento delle richieste HTTP.","exampleSolutionCode":"connection.setInstanceFollowRedirects(true);","fileName":"HttpServiceConfig.java"},{"name":"Tomcat Filter MemShell","description":"Questa classe contiene un filtro Tomcat che può essere utilizzato per iniettare un backdoor nel server. Il backdoor consente di eseguire comandi sul server tramite il parametro \u0027cmd_\u0027 in una richiesta HTTP.","severity":"serious","solution":"Rimuovere o disabilitare il filtro Tomcat MemShell. Assicurarsi che non ci siano altre vulnerabilità o backdoor presenti nel codice.","exampleSolutionCode":"standardContext.removeFilterDef(filterDef);\nstandardContext.removeFilterMap(filterMap);","fileName":"TomcatFilterMemShell.java"},{"name":"Command Injection","description":"La classe WebSocketsCmdEndpoint esegue comandi del sistema operativo senza alcun controllo sugli input dell\u0027utente, consentendo un potenziale attacco di command injection.","severity":"serious","solution":"Per risolvere questa vulnerabilità, è necessario implementare un controllo sugli input dell\u0027utente e sanitizzare correttamente i comandi prima di eseguirli.","exampleSolutionCode":"public void onMessage(String s) {\n  try {\n    // Sanitize input\n    String sanitizedInput \u003d sanitizeInput(s);\n\n    // Esegui il comando solo se è sicuro\n    if (isCommandSafe(sanitizedInput)) {\n      Process process;\n      boolean bool \u003d System.getProperty(\"os.name\").toLowerCase().startsWith(\"windows\");\n      if (bool) {\n        process \u003d Runtime.getRuntime().exec(new String[]{\"cmd.exe\", \"/c\", sanitizedInput});\n      } else {\n        process \u003d Runtime.getRuntime().exec(new String[]{\"/bin/bash\", \"-c\", sanitizedInput});\n      }\n      InputStream inputStream \u003d process.getInputStream();\n      StringBuilder stringBuilder \u003d new StringBuilder();\n      int i;\n      while ((i \u003d inputStream.read()) !\u003d -1) stringBuilder.append((char) i);\n      inputStream.close();\n      process.waitFor();\n      session.getBasicRemote().sendText(stringBuilder.toString());\n    } else {\n      // Comando non sicuro, gestisci l\u0027errore\n      session.getBasicRemote().sendText(\"Comando non consentito\");\n    }\n  } catch (Exception exception) {\n    exception.printStackTrace();\n  }\n}","fileName":"WebSocketsCmdEndpoint.java"},{"name":"Utilizzo di ByteBuffer senza limiti di dimensione","description":"Il codice utilizza ByteBuffer senza limiti di dimensione per leggere e scrivere dati. Questo può causare un utilizzo eccessivo della memoria e potenziali attacchi di tipo Denial of Service.","severity":"medio","solution":"Limitare la dimensione massima del ByteBuffer utilizzato per leggere e scrivere dati.","exampleSolutionCode":"final ByteBuffer buffer \u003d ByteBuffer.allocate(4096);","fileName":"WebSocketsProxyEndpoint.java"},{"name":"Manca la validazione del referer","description":"Il codice non effettua una valida validazione del referer","severity":"medium","solution":"Aggiungere una validazione del referer per evitare attacchi di CSRF","exampleSolutionCode":"if (!request.getHeader(\u0027referer\u0027).startsWith(\u0027https://example.com\u0027)) { \n throw new SecurityException(\u0027Invalid referer\u0027); \n }","fileName":"ReferFilter.java"},{"name":"Cors跨域漏洞","description":"该代码没有对Origin进行有效的校验，存在Cors跨域漏洞。攻击者可以通过构造恶意的Origin请求头绕过同源策略，从而进行跨域攻击。","severity":"serious","solution":"应该对Origin进行有效的校验，只允许特定的域名或IP访问。可以使用正则表达式或白名单机制来校验Origin。","exampleSolutionCode":"if (origin !\u003d null \u0026\u0026 (origin.equals(\"http://www.example.com\") || origin.equals(\"http://example.com\"))) {\n\t// 允许访问\n} else {\n\t// 拒绝访问\n}","fileName":"OriginFilter.java"},{"name":"CORS Misconfiguration","description":"La configurazione CORS non è corretta e potrebbe consentire richieste non autorizzate da origini non attendibili.","severity":"medium","solution":"Limitare gli origini consentiti solo a quelli attendibili.","exampleSolutionCode":"config.addAllowedOrigin(\"https://www.joychou.org\");","fileName":"BaseCorsFilter.java"},{"name":"Injection SQL","description":"La query \u0027select * from users where username \u003d \u0027${username}\u0027 permette l\u0027injection di codice SQL.","severity":"grave","solution":"Utilizzare sempre i prepared statements o parametrizzare le query per evitare l\u0027injection di codice SQL.","exampleSolutionCode":"@Select(\"select * from users where username \u003d #{username}\")\nList\u003cUser\u003e findByUserNameVuln01(@Param(\"username\") String username);","fileName":"UserMapper.java"},{"name":"Vulnerabilità SSRF","description":"La classe SSRFChecker contiene un metodo checkSSRF che effettua una richiesta HTTP all\u0027URL specificato senza alcun controllo o validazione. Questo può consentire a un attaccante di eseguire attacchi SSRF (Server Side Request Forgery) inviando richieste a risorse interne o esterne non autorizzate.","severity":"serio","solution":"Prima di effettuare la richiesta HTTP, è necessario implementare controlli e validazioni adeguati per garantire che l\u0027URL fornito sia sicuro e consentito. Ciò può includere la verifica del protocollo (solo http o https), il controllo dell\u0027URL rispetto a una lista di domini sicuri consentiti e la gestione corretta dei reindirizzamenti.","exampleSolutionCode":"public static boolean checkSSRF(String url, int checkTimes) {\n  \t// Esegui i controlli e le validazioni necessarie sull\u0027URL\n  \tif (!isValidURL(url)) {\n  \t\treturn false;\n  \t}\n\n  \t// Effettua la richiesta HTTP solo se l\u0027URL è sicuro e consentito\n  \t// ... rest of the code\n}","fileName":"SSRFChecker.java"},{"name":"Reflection Injection","description":"Il codice utilizza la riflessione per invocare metodi su oggetti senza controllare l\u0027input o verificare la sicurezza.","severity":"serious","solution":"Verificare l\u0027input prima di utilizzarlo nella riflessione e implementare controlli di sicurezza per prevenire l\u0027iniezione di codice dannoso.","exampleSolutionCode":"if (initSocketImpl \u003d\u003d null || !isInit) {\n  SocketHookFactory.setHook(false);\n  throw new RuntimeException(\"InitSocketImpl failed! Hook stopped!\");\n}","fileName":"SocketHookImpl.java"},{"name":"Reflection Injection","description":"Il codice utilizza la riflessione per accedere a metodi privati o protetti delle classi. Questo può consentire ad un attaccante di eseguire codice non autorizzato o ottenere informazioni sensibili.","severity":"serio","solution":"Evitare l\u0027uso della riflessione per accedere a metodi privati o protetti. Se necessario, utilizzare metodi pubblici o interfacce fornite dalla classe.","exampleSolutionCode":"public class MyClass {\n    public void myMethod() {\n        // Codice sicuro\n    }\n}","fileName":"SocketHookUtils.java"},{"name":"SSRF (Server-Side Request Forgery)","description":"La classe SocketHookFactory potrebbe essere vulnerabile a SSRF (Server-Side Request Forgery) se il valore della variabile \u0027isHook\u0027 viene controllato da input non attendibili. Questo potrebbe consentire a un attaccante di eseguire richieste verso risorse interne o esterne non autorizzate.","severity":"potenziale","solution":"Assicurarsi che il valore della variabile \u0027isHook\u0027 venga controllato da input attendibili e non consentire l\u0027accesso a risorse non autorizzate.","exampleSolutionCode":"setHook(true);","fileName":"SocketHookFactory.java"},{"name":"SSRF漏洞","description":"Il codice contiene una funzione checkSSRFByWhitehosts che verifica se l\u0027URL è sicuro. Tuttavia, questa funzione potrebbe non essere sufficiente per proteggere completamente dall\u0027attacco SSRF. È consigliabile utilizzare altre misure di sicurezza, come la verifica dell\u0027URL tramite una whitelist di domini consentiti.","severity":"medio","solution":"Utilizzare una combinazione di misure di sicurezza per proteggere dall\u0027attacco SSRF, come la verifica dell\u0027URL tramite una whitelist di domini consentiti, la limitazione delle richieste di reindirizzamento e l\u0027uso di IP interni.","exampleSolutionCode":"public static boolean checkSSRFByWhitehosts(String url) {\n    return SSRFChecker.checkURLFckSSRF(url);\n}","fileName":"SecurityUtil.java"},{"name":"CSRF","description":"La configurazione CSRF potrebbe essere disabilitata o non correttamente configurata, consentendo attacchi CSRF.","severity":"serious","solution":"Abilitare e configurare correttamente la protezione CSRF per prevenire attacchi CSRF.","exampleSolutionCode":"http.csrf()\n    .requireCsrfProtectionMatcher(csrfRequestMatcher)\n    .ignoringAntMatchers(csrfExcludeUrl)\n    .csrfTokenRepository(new CookieCsrfTokenRepository());","fileName":"WebSecurityConfig.java"},{"name":"Insecure CORS Configuration","description":"La configurazione CORS non è sicura e potrebbe consentire richieste da origini non attendibili.","severity":"medium","solution":"Impostare correttamente la configurazione CORS per consentire solo richieste da origini attendibili.","exampleSolutionCode":"config.addAllowedOrigin(\"https://www.example.com\");","fileName":"CustomCorsProcessor.java"},{"name":"Insecure Logging","description":"The code logs sensitive information (username and password) in plain text.","severity":"serious","solution":"Do not log sensitive information. Instead, log a generic message without including the actual values.","exampleSolutionCode":"logger.info(\"Login failed. \" + request.getRequestURL() + \" username: [REDACTED] password: [REDACTED]\");","fileName":"LoginFailureHandler.java"},{"name":"Potential Open Redirect","description":"The \u0027originUrl\u0027 variable is not properly validated before being used in a redirect. This can allow an attacker to redirect users to malicious websites.","severity":"potential","solution":"Validate the \u0027originUrl\u0027 variable to ensure it is a trusted URL before using it in a redirect.","exampleSolutionCode":"if (isValidUrl(originUrl)) {\n    response.sendRedirect(originUrl);\n}","fileName":"LoginSuccessHandler.java"},{"name":"Deserialization vulnerability","description":"La classe AntObjectInputStream estende ObjectInputStream e sovrascrive il metodo resolveClass(). Questo metodo viene chiamato durante la deserializzazione di un oggetto e consente di risolvere la classe dell\u0027oggetto. Tuttavia, la classe non effettua alcun controllo sulle classi che possono essere deserializzate, consentendo potenziali attacchi di deserializzazione.","severity":"serious","solution":"Per mitigare questa vulnerabilità, è necessario implementare un meccanismo di controllo sulle classi che possono essere deserializzate. È possibile utilizzare una lista nera o una lista bianca per specificare le classi consentite o non consentite durante la deserializzazione.","exampleSolutionCode":"protected Class\u003c?\u003e resolveClass(final ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n    String className \u003d desc.getName();\n    if (!isAllowed(className)) {\n        throw new InvalidClassException(\"Unauthorized deserialization attempt\", className);\n    }\n    return super.resolveClass(desc);\n}","fileName":"AntObjectInputStream.java"},{"name":"Access Denied Page Vulnerability","description":"La pagina di accesso negato mostra informazioni sensibili come URL e referer.","severity":"medium","solution":"Evitare di mostrare informazioni sensibili nella pagina di accesso negato.","exampleSolutionCode":"response.getWriter().write(\"Accesso negato.\");","fileName":"CsrfAccessDeniedHandler.java"},{"name":"Disabilitazione del firewall di sicurezza di Spring","description":"La classe DisableSpringSecurityFirewall disabilita il firewall di sicurezza di Spring.","severity":"medio","solution":"Non disabilitare il firewall di sicurezza di Spring in modo da garantire la protezione dell\u0027applicazione.","exampleSolutionCode":"Rimuovere la classe DisableSpringSecurityFirewall o reimplementarla in modo che non disabiliti il firewall di sicurezza di Spring.","fileName":"DisableSpringSecurityFirewall.java"},{"name":"Vulnerabilità di XSS","description":"Il valore del cookie USER_COOKIE viene utilizzato direttamente nel metodo getNickname senza essere sanitizzato o validato.","severity":"serio","solution":"Sanitizzare e validare il valore del cookie prima di utilizzarlo nel codice.","exampleSolutionCode":"String nickname \u003d JwtUtils.getNicknameByJavaJwt(sanitize(user_cookie));","fileName":"Jwt.java"},{"name":"Command Injection","description":"L\u0027applicazione esegue comandi del sistema operativo senza validare o filtrare l\u0027input dell\u0027utente, consentendo ad un attaccante di eseguire comandi arbitrari.","severity":"serious","solution":"Validare e filtrare l\u0027input dell\u0027utente per evitare l\u0027esecuzione di comandi non autorizzati. Utilizzare metodi sicuri per eseguire comandi di sistema, come ProcessBuilder.","exampleSolutionCode":"ProcessBuilder processBuilder \u003d new ProcessBuilder(arrCmd);\nProcess p \u003d processBuilder.start();","fileName":"Rce.java"},{"name":"Stored XSS","description":"Il codice contiene una vulnerabilità di tipo Stored XSS, che permette l\u0027inserimento di codice JavaScript dannoso all\u0027interno di un cookie.","severity":"serio","solution":"Per risolvere la vulnerabilità di Stored XSS, è necessario effettuare una corretta validazione e sanitizzazione dei dati inseriti dall\u0027utente prima di memorizzarli all\u0027interno del cookie. Inoltre, è consigliabile utilizzare l\u0027header HttpOnly per impedire l\u0027accesso al cookie tramite JavaScript.","exampleSolutionCode":"public String store(String xss, HttpServletResponse response) {\n  String sanitizedXss \u003d sanitize(xss);\n  Cookie cookie \u003d new Cookie(\"xss\", sanitizedXss);\n  cookie.setHttpOnly(true);\n  response.addCookie(cookie);\n  return \"Parametro inserito nel cookie\";\n}\n\nprivate String sanitize(String input) {\n  // Effettua la sanitizzazione del parametro input\n  return sanitizedInput;\n}","fileName":"XSS.java"},{"name":"XML External Entity (XXE)","description":"Il codice utilizza parser XML vulnerabili che permettono l\u0027inclusione di entità esterne","severity":"serio","solution":"Utilizzare parser XML sicuri che disabilitino le funzionalità di inclusione di entità esterne","exampleSolutionCode":"xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\nxmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\nxmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);","fileName":"XXE.java"},{"name":"Vulnerabilità CORS","description":"La configurazione CORS non è corretta e potrebbe consentire attacchi di Cross-Origin Resource Sharing (CORS).","severity":"serio","solution":"Configurare correttamente le impostazioni CORS per limitare l\u0027accesso ai domini autorizzati e prevenire attacchi di tipo CORS.","exampleSolutionCode":"response.setHeader(\"Access-Control-Allow-Origin\", \"https://www.example.com\");","fileName":"Cors.java"},{"name":"CVE-2022-21724","description":"La vulnerabilità CVE-2022-21724 consente agli attaccanti di eseguire attacchi JDBC attraverso un URL JDBC malevolo.","severity":"grave","solution":"Per risolvere questa vulnerabilità, è necessario validare e sanificare l\u0027URL JDBC prima di utilizzarlo per connettersi al database. Inoltre, è consigliabile utilizzare librerie di terze parti per gestire in modo sicuro le connessioni al database.","exampleSolutionCode":"byte[] b \u003d java.util.Base64.getDecoder().decode(jdbcUrlBase64);\nString jdbcUrl \u003d new String(b);\njdbcUrl \u003d sanitize(jdbcUrl);\nlog.info(jdbcUrl);\nDriverManager.getConnection(jdbcUrl);","fileName":"Jdbc.java"},{"name":"Iniezione SpEL","description":"L\u0027applicazione utilizza l\u0027espressione SpEL senza una corretta validazione o sanitizzazione dei dati in ingresso, consentendo agli attaccanti di eseguire codice arbitrario sul server.","severity":"Serio","solution":"Per prevenire l\u0027iniezione SpEL, è necessario validare e sanitizzare correttamente i dati in ingresso prima di utilizzarli nell\u0027espressione SpEL. Utilizzare metodi come ExpressionUtils#isExpressionLanguage() per verificare se l\u0027input contiene espressioni SpEL.","exampleSolutionCode":"public String rce(String expression) {\n  if (ExpressionUtils.isExpressionLanguage(expression)) {\n    return \"Invalid expression\";\n  }\n\n  ExpressionParser parser \u003d new SpelExpressionParser();\n  return parser.parseExpression(expression).getValue().toString();\n}","fileName":"SpEL.java"},{"name":"SQL Injection","description":"La vulnerabilità di SQL Injection consente a un attaccante di inserire o manipolare query SQL non protette in un\u0027applicazione web. Ciò può consentire all\u0027attaccante di visualizzare, modificare o eliminare dati nel database o eseguire operazioni non autorizzate.","severity":"serious","solution":"Per proteggere l\u0027applicazione da SQL Injection, è necessario utilizzare sempre PreparedStatement o metodi equivalenti per creare query SQL parametriche. In questo modo, i parametri vengono correttamente trattati e sanificati, evitando l\u0027iniezione di SQL.","exampleSolutionCode":"String sql \u003d \"select * from users where username \u003d ?\";\nPreparedStatement st \u003d con.prepareStatement(sql);\nst.setString(1, username);\nResultSet rs \u003d st.executeQuery();","fileName":"SQLI.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"Java SSRF","description":"Il codice contiene una vulnerabilità SSRF (Server Side Request Forgery), che consente a un attaccante di forzare il server a fare richieste a risorse esterne non autorizzate.","severity":"serio","solution":"Per mitigare questa vulnerabilità, è necessario implementare controlli sulle URL fornite dagli utenti, verificando che siano valide e consentendo solo protocolli sicuri come HTTP e HTTPS.","exampleSolutionCode":"if (!SecurityUtil.isHttp(url)) {\n    return \"[-] Controllo SSRF fallito\";\n}","fileName":"SSRF.java"},{"name":"SSTI (Server Side Template Injection)","description":"L\u0027applicazione utilizza Velocity per l\u0027elaborazione dei template, ma non controlla adeguatamente i dati inseriti dall\u0027utente, consentendo l\u0027iniezione di codice malevolo.","severity":"grave","solution":"Evitare di utilizzare il metodo Velocity.evaluate per l\u0027elaborazione dei template. Utilizzare invece un meccanismo di rendering dei template che fornisca una protezione adeguata contro le SSTI, come ad esempio l\u0027utilizzo di un motore di template che implementa un sistema di sandboxing.","exampleSolutionCode":"Per esempio, si può utilizzare il motore di template FreeMarker che offre una protezione nativa contro le SSTI. Invece di utilizzare Velocity.evaluate, si può utilizzare il metodo processTemplateIntoString di FreeMarker per elaborare il template in modo sicuro.","fileName":"SSTI.java"},{"name":"Cross-Site Scripting (XSS)","description":"Il codice utilizza dati non filtrati dall\u0027utente nel metodo System.out.println, che potrebbe consentire l\u0027esecuzione di codice JavaScript dannoso sul browser dell\u0027utente.","severity":"serio","solution":"Filtrare e validare i dati inseriti dall\u0027utente prima di utilizzarli nel codice.","exampleSolutionCode":"String empIdFiltered \u003d filterAndValidate(empId);","fileName":"Test.java"},{"name":"JSONP Injection","description":"Il codice utilizza il parametro callback direttamente per generare una risposta JSONP senza alcun controllo o sanitizzazione.","severity":"serious","solution":"Sanitizzare il parametro callback prima di utilizzarlo per generare la risposta JSONP. Verificare che il parametro contenga solo caratteri alfanumerici.","exampleSolutionCode":"String callback \u003d request.getParameter(this.callback);\nif (!callback.matches(\"^[a-zA-Z0-9]+$\")) {\n    return \"error\";\n}\nreturn WebUtils.json2Jsonp(callback, LoginUtils.getUserInfo2JsonStr(request));","fileName":"Jsonp.java"},{"name":"Insecure Log4j Configuration","description":"La configurazione di Log4j permette l\u0027inserimento di payload dannosi tramite il parametro \u0027token\u0027, che potrebbe portare ad attacchi di tipo injection.","severity":"serious","solution":"Aggiorna Log4j all\u0027ultima versione per correggere questa vulnerabilità.","exampleSolutionCode":"Aggiorna la dipendenza di Log4j nel file pom.xml o build.gradle alla versione più recente.","fileName":"Log4j.java"},{"name":"Gestione errata del logout","description":"La gestione del logout potrebbe non essere corretta, permettendo a un utente di effettuare il logout anche se non è autenticato.","severity":"potenziale","solution":"Verificare che l\u0027utente sia autenticato prima di effettuare il logout.","exampleSolutionCode":"if (request.getUserPrincipal() !\u003d null) {\n    // Effettua il logout\n}","fileName":"Login.java"},{"name":"Vulnerabilità XXE","description":"Questa classe di controller utilizza la libreria Apache POI per leggere file Excel (.xlsx). Tuttavia, il codice non effettua alcun controllo sul contenuto del file caricato, aprendo la porta a una potenziale vulnerabilità XXE (XML External Entity). Un attaccante potrebbe sfruttare questa vulnerabilità per eseguire attacchi di tipo XXE, che potrebbero consentire la lettura di file arbitrari sul server o l\u0027esecuzione di codice remoto.","severity":"serio","solution":"Per risolvere questa vulnerabilità, è necessario implementare controlli adeguati sul file caricato per prevenire l\u0027elaborazione di eventuali entità esterne o risorse esterne. È possibile utilizzare metodi come la validazione dello schema XML o la disabilitazione delle funzionalità di elaborazione delle entità esterne.","exampleSolutionCode":"Esempio di codice per risolvere la vulnerabilità XXE:\n\n// Imposta la configurazione del parser XML per disabilitare le entità esterne\nDocumentBuilderFactory factory \u003d DocumentBuilderFactory.newInstance();\nfactory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\nfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\nfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\n// Esegui il parsing del documento XML\nDocumentBuilder builder \u003d factory.newDocumentBuilder();\nDocument document \u003d builder.parse(file.getInputStream());","fileName":"ooxmlXXE.java"},{"name":"xxe","description":"Il codice contiene una vulnerabilità di XXE (XML External Entity) che può consentire a un attaccante di leggere file arbitrari dal server.","severity":"grave","solution":"Aggiorna xlsx-streamer alla versione 2.1.0 o successiva.","exampleSolutionCode":"StreamingReader.builder().open(file.getInputStream());","fileName":"xlsxStreamerXXE.java"},{"name":"Spring Security CVE-2022-22978","description":"Questa vulnerabilità permette a un attaccante di bypassare le restrizioni di sicurezza di Spring Security.","severity":"serious","solution":"Aggiornare la versione di Spring Security alla versione 5.5.7 o successiva.","exampleSolutionCode":"import org.springframework.security.core.context.SecurityContextHolder;\n\npublic class Dotall {\n\n    public static void main(String[] args) throws Exception{\n        Pattern vuln_pattern \u003d Pattern.compile(\"/black_path.*\");\n        Pattern sec_pattern \u003d Pattern.compile(\"/black_path.*\", Pattern.DOTALL);\n\n        String poc \u003d URLDecoder.decode(\"/black_path%0a/xx\", StandardCharsets.UTF_8.toString());\n        System.out.println(\"Poc: \" + poc);\n        System.out.println(\"Not dotall: \" + vuln_pattern.matcher(poc).matches());\n        System.out.println(\"Dotall: \" + sec_pattern.matcher(poc).matches());\n    }\n}","fileName":"Dotall.java"},{"name":"Accesso non autorizzato tramite cookie","description":"Alcune applicazioni potrebbero ottenere le informazioni di identificazione dell\u0027utente direttamente dai cookie in chiaro, causando problemi di accesso non autorizzato.","severity":"serio","solution":"Per evitare problemi di accesso non autorizzato, è consigliabile crittografare le informazioni di identificazione dell\u0027utente nei cookie e utilizzare meccanismi di autenticazione sicuri.","exampleSolutionCode":"Utilizzare un algoritmo di crittografia per crittografare le informazioni di identificazione dell\u0027utente nei cookie e utilizzare un meccanismo di autenticazione sicuro come JWT (JSON Web Token).","fileName":"Cookies.java"},{"name":"Utilizzo di X-Forwarded-For per ottenere l\u0027indirizzo IP","description":"L\u0027utilizzo di X-Forwarded-For per ottenere l\u0027indirizzo IP può essere vulnerabile a spoofing dell\u0027indirizzo IP. Questo può consentire a un attaccante di falsificare l\u0027indirizzo IP e impersonare un\u0027altra persona o dispositivo.","severity":"potenziale","solution":"Utilizzare l\u0027header X-Real-IP per ottenere l\u0027indirizzo IP invece di X-Forwarded-For. Assicurarsi che l\u0027header X-Real-IP sia impostato correttamente nel server proxy.","exampleSolutionCode":"String ip \u003d request.getHeader(\"X-Real-IP\");","fileName":"IPForge.java"},{"name":"Deserializzazione non sicura","description":"La classe Fastjson utilizza il metodo parseObject per deserializzare un oggetto JSON senza controllare adeguatamente la sua sicurezza. Questo può portare a vulnerabilità di deserializzazione non sicure.","severity":"seria","solution":"Per evitare questa vulnerabilità, è consigliabile utilizzare librerie di deserializzazione sicure come Jackson o Gson, che implementano controlli di sicurezza adeguati durante la deserializzazione.","exampleSolutionCode":"import com.fasterxml.jackson.databind.ObjectMapper;\n\nObjectMapper objectMapper \u003d new ObjectMapper();\nMyObject obj \u003d objectMapper.readValue(jsonString, MyObject.class);","fileName":"Fastjson.java"},{"name":"Insecure File Upload","description":"Il codice non effettua controlli sufficienti sul tipo di file caricato, consentendo a un utente malintenzionato di caricare file eseguibili o script dannosi.","severity":"serious","solution":"Implementare controlli per verificare il tipo di file caricato, ad esempio controllando l\u0027estensione del file o il tipo MIME. Inoltre, è consigliabile rinominare il file caricato in modo casuale per evitare il sovrascrivere di file esistenti o l\u0027accesso diretto a file caricati.","exampleSolutionCode":"String[] allowedExtensions \u003d {\".jpg\", \".png\", \".jpeg\", \".gif\", \".bmp\", \".ico\"};\nString fileExtension \u003d fileName.substring(fileName.lastIndexOf(\".\"));\nboolean isAllowedExtension \u003d Arrays.stream(allowedExtensions).anyMatch(ext -\u003e ext.equalsIgnoreCase(fileExtension));\nif (!isAllowedExtension) {\n    // handle error\n}","fileName":"FileUpload.java"},{"name":"MIME Type Validation Bypass","description":"Il codice utilizza un approccio non sicuro per verificare il tipo MIME del file caricato, consentendo a un utente malintenzionato di caricare file dannosi con un tipo MIME modificato.","severity":"serious","solution":"Utilizzare un metodo più sicuro per verificare il tipo MIME del file caricato, ad esempio utilizzando una libreria di convalida del tipo MIME o confrontando l\u0027estensione del file con il tipo MIME dichiarato.","exampleSolutionCode":"String[] allowedMimeTypes \u003d {\"image/jpeg\", \"image/png\", \"image/gif\", \"image/bmp\", \"image/x-icon\"};\nboolean isAllowedMimeType \u003d Arrays.stream(allowedMimeTypes).anyMatch(mimeType::equalsIgnoreCase);\nif (!isAllowedMimeType) {\n    // handle error\n}","fileName":"FileUpload.java"},{"name":"File Content Validation","description":"Il codice non effettua controlli sufficienti sul contenuto del file caricato, consentendo a un utente malintenzionato di caricare file non validi o dannosi.","severity":"medium","solution":"Implementare controlli per verificare che il file caricato sia un\u0027immagine valida, ad esempio utilizzando una libreria di convalida delle immagini o verificando la struttura del file.","exampleSolutionCode":"private static boolean isImage(File file) throws IOException {\n    BufferedImage bi \u003d ImageIO.read(file);\n    return bi !\u003d null;\n}","fileName":"FileUpload.java"},{"name":"Injection di comandi","description":"Il codice accetta un parametro \u0027path\u0027 dall\u0027utente senza alcun controllo o validazione. Questo parametro viene utilizzato direttamente nella creazione di un oggetto ServerEndpointConfig. Un attaccante potrebbe sfruttare questa vulnerabilità per eseguire comandi arbitrari sul server.","severity":"grave","solution":"Validare e filtrare il parametro \u0027path\u0027 per evitare l\u0027iniezione di comandi. Utilizzare solo valori predefiniti o consentiti per la creazione di oggetti ServerEndpointConfig.","exampleSolutionCode":"String path \u003d req.getParameter(\"path\");\nif (path \u003d\u003d null || !isValidPath(path)) {\n    return \"path is invalid\";\n}\n\nprivate boolean isValidPath(String path) {\n    // Implementare la logica per verificare se il path è valido\n    return true;\n}","fileName":"WebSockets.java"},{"name":"XStream RCE","description":"L\u0027applicazione utilizza una versione vulnerabile di XStream che consente l\u0027esecuzione remota di codice (RCE).","severity":"serious","solution":"Aggiorna XStream alla versione 1.4.11 o successiva.","exampleSolutionCode":"dependencies {\n    implementation \u0027com.thoughtworks.xstream:xstream:1.4.11\u0027\n}","fileName":"XStreamRce.java"},{"name":"Deserialization vulnerability","description":"Il codice utilizza la deserializzazione di oggetti senza verificare la loro sicurezza, consentendo potenziali attacchi di Remote Code Execution (RCE).","severity":"serious","solution":"È necessario implementare controlli di sicurezza sulla deserializzazione degli oggetti, come l\u0027utilizzo di una whitelist di classi consentite o l\u0027uso di librerie di deserializzazione sicure.","exampleSolutionCode":"public class SecureObjectInputStream extends ObjectInputStream {\n    \n    private static final Set\u003cClass\u003c?\u003e\u003e allowedClasses \u003d new HashSet\u003c\u003e();\n    \n    static {\n        allowedClasses.add(TrustedClass1.class);\n        allowedClasses.add(TrustedClass2.class);\n    }\n    \n    public SecureObjectInputStream(InputStream in) throws IOException {\n        super(in);\n    }\n    \n    @Override\n    protected Class\u003c?\u003e resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n        if (!allowedClasses.contains(desc.forClass())) {\n            throw new InvalidClassException(\"Unauthorized deserialization attempt\", desc.getName());\n        }\n        return super.resolveClass(desc);\n    }\n}","fileName":"Deserialize.java"},{"name":"URL Redirect","description":"Il codice contiene una vulnerabilità di reindirizzamento non controllato.","severity":"serio","solution":"Controllare l\u0027URL di reindirizzamento per assicurarsi che sia presente in una whitelist di URL consentiti.","exampleSolutionCode":"if (url.startsWith(\"http://localhost:8080\") || url.startsWith(\"http://www.example.com\")) {\n    return \"redirect:\" + url;\n} else {\n    return \"redirect:/\";\n}","fileName":"URLRedirect.java"},{"name":"Whitelist Bypass","description":"Il codice utilizza una whitelist per controllare gli URL, ma è vulnerabile a bypassare la whitelist utilizzando URL che terminano con il dominio consentito o che contengono il dominio consentito.","severity":"serious","solution":"Per risolvere questa vulnerabilità, è necessario utilizzare un controllo più accurato per verificare l\u0027URL. Ad esempio, è possibile utilizzare l\u0027equals() o il metodo endsWith() con un controllo completo del dominio.","exampleSolutionCode":"if (host.equals(domain)) {\n    return \"Good url.\";\n}","fileName":"URLWhiteList.java"},{"name":"Whitelist Bypass","description":"Il codice utilizza una whitelist per controllare gli URL, ma è vulnerabile a bypassare la whitelist utilizzando URL che contengono il dominio consentito.","severity":"serious","solution":"Per risolvere questa vulnerabilità, è necessario utilizzare un controllo più accurato per verificare l\u0027URL. Ad esempio, è possibile utilizzare il metodo contains() con un controllo completo del dominio.","exampleSolutionCode":"if (host.contains(domain)) {\n    return \"Good url.\";\n}","fileName":"URLWhiteList.java"},{"name":"Whitelist Bypass","description":"Il codice utilizza una whitelist per controllare gli URL, ma è vulnerabile a bypassare la whitelist utilizzando un\u0027espressione regolare non sicura per verificare il dominio.","severity":"serious","solution":"Per risolvere questa vulnerabilità, è necessario utilizzare un\u0027espressione regolare sicura per verificare il dominio. Ad esempio, è possibile utilizzare l\u0027espressione regolare \"^joychou\\\\.org$\".","exampleSolutionCode":"Pattern p \u003d Pattern.compile(\"^joychou\\\\.org$\");\nMatcher m \u003d p.matcher(host);\n\nif (m.find()) {\n    return \"Good url.\";\n} else {\n    return \"Bad url.\";\n}","fileName":"URLWhiteList.java"},{"name":"Whitelist Bypass","description":"Il codice utilizza una whitelist per controllare gli URL, ma è vulnerabile a bypassare la whitelist utilizzando la classe URL per ottenere l\u0027host.","severity":"serious","solution":"Per risolvere questa vulnerabilità, è necessario utilizzare un metodo più sicuro per ottenere l\u0027host dell\u0027URL. Ad esempio, è possibile utilizzare il metodo SecurityUtil.gethost() invece della classe URL.","exampleSolutionCode":"String host \u003d SecurityUtil.gethost(url);","fileName":"URLWhiteList.java"},{"name":"Command Injection","description":"L\u0027applicazione esegue comandi di sistema senza validare o filtrare i dati di input dell\u0027utente, consentendo agli attaccanti di eseguire comandi arbitrari sul server.","severity":"serious","solution":"Validare e filtrare attentamente i dati di input dell\u0027utente prima di utilizzarli per eseguire comandi di sistema. Utilizzare metodi sicuri per eseguire comandi di sistema, come ad esempio l\u0027utilizzo di API specifiche del linguaggio o l\u0027utilizzo di librerie di terze parti che gestiscono correttamente l\u0027input dell\u0027utente.","exampleSolutionCode":"String[] cmdList \u003d new String[]{\"sh\", \"-c\", \"ls -la \" + sanitize(filepath)};\nProcessBuilder builder \u003d new ProcessBuilder(cmdList);\nbuilder.redirectErrorStream(true);\nProcess process \u003d builder.start();","fileName":"CommandInject.java"},{"name":"CRLF Injection","description":"L\u0027iniezione di CRLF (Carriage Return Line Feed) si verifica quando un\u0027applicazione web accetta input dall\u0027utente e lo utilizza per creare una risposta HTTP senza sanitizzare o validare correttamente l\u0027input. Questo può consentire a un attaccante di iniettare sequenze di caratteri speciali come il ritorno a capo e il avanzamento di riga, che possono essere utilizzate per manipolare l\u0027output o inserire contenuti dannosi.","severity":"medium","solution":"Per proteggere l\u0027applicazione da un attacco di iniezione CRLF, è necessario validare e sanitizzare correttamente l\u0027input dell\u0027utente prima di utilizzarlo per creare una risposta HTTP. Utilizzare metodi di sanitizzazione come l\u0027escape dei caratteri speciali o la rimozione dei caratteri non validi.","exampleSolutionCode":"String author \u003d request.getParameter(\"test3\");\nauthor \u003d author.replaceAll(\"\\\\r\", \"\").replaceAll(\"\\\\n\", \"\");\nCookie cookie \u003d new Cookie(\"test3\", author);\nresponse.addCookie(cookie);","fileName":"CRLFInjection.java"},{"name":"Bypassing URL Path Security Check","description":"Il codice utilizza getRequestURI invece di getServletPath per verificare la sicurezza del percorso URL, consentendo potenzialmente a un utente malintenzionato di bypassare i controlli di sicurezza.","severity":"serious","solution":"Utilizzare getServletPath invece di getRequestURI per verificare la sicurezza del percorso URL.","exampleSolutionCode":"uri \u003d request.getServletPath();","fileName":"GetRequestURI.java"},{"name":"Path Traversal","description":"La vulnerabilità di Path Traversal consente a un attaccante di accedere a file o directory al di fuori della directory prevista.","severity":"serious","solution":"Per risolvere questa vulnerabilità, è necessario implementare un meccanismo di filtraggio dei percorsi dei file in modo che solo i percorsi validi siano consentiti.","exampleSolutionCode":"public String getImageSec(String filepath) throws IOException {\n  if (SecurityUtil.pathFilter(filepath) \u003d\u003d null) {\n    logger.info(\"Illegal file path: \" + filepath);\n    return \"Bad boy. Illegal file path.\";\n  }\n  return getImgBase64(filepath);\n}","fileName":"PathTraversal.java"},{"name":"Remote Code Execution","description":"Il codice accetta un parametro \u0027classData\u0027 dall\u0027utente e lo utilizza per caricare una classe dinamicamente. Questo può portare ad un\u0027attacco di Remote Code Execution.","severity":"serio","solution":"Validare e filtrare il parametro \u0027classData\u0027 per impedire l\u0027iniezione di codice dannoso. Utilizzare metodi di sicurezza come sandboxing o class loader personalizzati per limitare l\u0027accesso alle risorse di sistema.","exampleSolutionCode":"String classData \u003d request.getParameter(\"classData\");\n\n// Validazione e filtraggio del parametro classData\nif (isValid(classData)) {\n    byte[] classBytes \u003d java.util.Base64.getDecoder().decode(classData);\n    // Resto del codice...\n}","fileName":"ClassDataLoader.java"},{"name":"Path Traversal","description":"La configurazione del resource handler permette di accedere a file al di fuori della directory specificata.","severity":"serio","solution":"Verificare che la directory specificata sia sicura e limitata solo ai file che devono essere resi accessibili.","exampleSolutionCode":"registry.addResourceHandler(\"/image/**\").addResourceLocations(\"file:/path/to/secure/directory/\");","fileName":"imageConfig.java"}]