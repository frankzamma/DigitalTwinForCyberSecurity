[{"name":"Injection di codice SQL","description":"Il codice contiene una vulnerabilità di injection di codice SQL. La query SQL viene costruita concatenando direttamente i valori degli utenti senza utilizzare parametri o escape characters, consentendo agli attaccanti di eseguire codice SQL dannoso.","severity":"serio","solution":"Per prevenire l\u0027injection di codice SQL, è consigliabile utilizzare parametri nelle query SQL o utilizzare escape characters per evitare l\u0027esecuzione di codice dannoso. Ad esempio, è possibile utilizzare il metodo execute() con i parametri nella libreria sqlite3 o utilizzare metodi di escape come quote() o escape_string().","exampleSolutionCode":"connection.execute(\u0027INSERT INTO users(id, username, firstname, lastname, email, password, session) VALUES(NULL, ?, ?, ?, ?, ?, ?)\u0027, user)","fileName":"server.py"},{"name":"SQL Injection","description":"La vulnerabilità di SQL Injection si verifica quando un\u0027applicazione web non valida o filtra correttamente i dati forniti dall\u0027utente prima di utilizzarli in una query SQL. Ciò consente a un attaccante di eseguire query non autorizzate o alterare le query esistenti per ottenere, modificare o eliminare dati sensibili.","severity":"serio","solution":"Per prevenire le SQL Injection, è necessario utilizzare parametri interrogativi o statement preparati per separare i dati utente dalle query SQL. Inoltre, è consigliabile utilizzare librerie di accesso al database che supportano l\u0027escape dei caratteri speciali o l\u0027uso di query parametriche.","exampleSolutionCode":"cursor.execute(\u0027SELECT id, username, firstname, lastname, email, session FROM users WHERE id \u003d ?\u0027, [id])","fileName":"attacks.py"},{"name":"XSS Reflected","description":"La vulnerabilità di XSS Reflected si verifica quando un\u0027applicazione web non valida o filtra correttamente i dati forniti dall\u0027utente prima di restituirli al browser. Ciò consente a un attaccante di inserire script dannosi che verranno eseguiti nel contesto del sito web.","severity":"medio","solution":"Per prevenire gli attacchi XSS Reflected, è necessario validare e filtrare correttamente i dati forniti dall\u0027utente prima di restituirli al browser. Ciò può essere fatto utilizzando librerie di sanitizzazione HTML o implementando una politica di sicurezza del contenuto (CSP) che limita l\u0027esecuzione di script non autorizzati.","exampleSolutionCode":"content \u003d html.escape(content)","fileName":"attacks.py"},{"name":"XSS Stored","description":"La vulnerabilità di XSS Stored si verifica quando un\u0027applicazione web non valida o filtra correttamente i dati forniti dall\u0027utente prima di salvarli nel database. Ciò consente a un attaccante di inserire script dannosi che verranno eseguiti quando i dati vengono visualizzati da altri utenti.","severity":"medio","solution":"Per prevenire gli attacchi XSS Stored, è necessario validare e filtrare correttamente i dati forniti dall\u0027utente prima di salvarli nel database. Inoltre, è consigliabile utilizzare librerie di sanitizzazione HTML o implementare una politica di sicurezza del contenuto (CSP) che limita l\u0027esecuzione di script non autorizzati.","exampleSolutionCode":"comment \u003d html.escape(comment)","fileName":"attacks.py"},{"name":"Unvalidated Redirect","description":"La vulnerabilità di Unvalidated Redirect si verifica quando un\u0027applicazione web reindirizza l\u0027utente a una pagina specificata dai parametri dell\u0027URL senza convalidare o filtrare correttamente l\u0027URL di destinazione. Ciò consente a un attaccante di reindirizzare l\u0027utente a un sito malevolo o di eseguire altre azioni indesiderate.","severity":"medio","solution":"Per prevenire gli attacchi di Unvalidated Redirect, è necessario convalidare e filtrare correttamente l\u0027URL di destinazione prima di reindirizzare l\u0027utente. È possibile utilizzare librerie o funzioni di convalida degli URL per garantire che l\u0027URL sia valido e sicuro.","exampleSolutionCode":"path \u003d validate_url(path)","fileName":"attacks.py"},{"name":"Execution After Redirect","description":"La vulnerabilità di Execution After Redirect si verifica quando un\u0027applicazione web esegue azioni non sicure dopo un reindirizzamento senza verificare se l\u0027utente è autorizzato a eseguirle. Ciò consente a un attaccante di eseguire azioni non autorizzate o di ottenere informazioni sensibili.","severity":"medio","solution":"Per prevenire gli attacchi di Execution After Redirect, è necessario verificare l\u0027autenticazione o l\u0027autorizzazione dell\u0027utente prima di eseguire azioni non sicure dopo un reindirizzamento. È possibile utilizzare sessioni, token di autenticazione o altre forme di autenticazione per garantire che solo gli utenti autorizzati possano eseguire tali azioni.","exampleSolutionCode":"if not cookie:\n    content +\u003d \"\u003cscript\u003ewindow.location \u003d \u0027/login\u0027;\u003c/script\u003e\"","fileName":"attacks.py"},{"name":"Command Injection","description":"La vulnerabilità di Command Injection si verifica quando un\u0027applicazione web esegue comandi di sistema utilizzando dati forniti dall\u0027utente senza convalidare o filtrare correttamente tali dati. Ciò consente a un attaccante di eseguire comandi non autorizzati o dannosi sul server.","severity":"serio","solution":"Per prevenire gli attacchi di Command Injection, è necessario convalidare e filtrare correttamente i dati forniti dall\u0027utente prima di utilizzarli per eseguire comandi di sistema. È possibile utilizzare librerie o funzioni specifiche per il linguaggio di programmazione utilizzato per garantire che i dati siano sicuri e non possano essere interpretati come comandi.","exampleSolutionCode":"output \u003d subprocess.check_output([command, domain])","fileName":"attacks.py"},{"name":"Unsafe Deserialization","description":"La vulnerabilità di Unsafe Deserialization si verifica quando un\u0027applicazione web deserializza dati provenienti da una fonte non fidata senza verificare o filtrare correttamente tali dati. Ciò consente a un attaccante di eseguire codice dannoso o ottenere accesso non autorizzato al sistema.","severity":"serio","solution":"Per prevenire gli attacchi di Unsafe Deserialization, è necessario verificare e filtrare correttamente i dati deserializzati provenienti da una fonte non fidata. È possibile utilizzare librerie o funzioni specifiche per il linguaggio di programmazione utilizzato per garantire che i dati siano sicuri e non possano essere interpretati come codice dannoso.","exampleSolutionCode":"content \u003d str(pickle.loads(base64.urlsafe_b64decode(object)))","fileName":"attacks.py"},{"name":"Path Traversal","description":"La vulnerabilità di Path Traversal si verifica quando un\u0027applicazione web consente a un utente di accedere a file o directory al di fuori della directory prevista. Ciò consente a un attaccante di leggere, modificare o eliminare file sensibili sul server.","severity":"medio","solution":"Per prevenire gli attacchi di Path Traversal, è necessario convalidare e filtrare correttamente i percorsi dei file forniti dall\u0027utente. È possibile utilizzare funzioni specifiche per il linguaggio di programmazione utilizzato per garantire che i percorsi dei file siano limitati alla directory prevista e non consentano l\u0027accesso a file o directory sensibili.","exampleSolutionCode":"file \u003d open(os.path.abspath(path), \u0027rb\u0027)","fileName":"attacks.py"},{"name":"Session Fixation","description":"La vulnerabilità di Session Fixation si verifica quando un\u0027applicazione web non rigenera correttamente l\u0027ID di sessione dopo l\u0027autenticazione o il cambio di utente. Ciò consente a un attaccante di utilizzare un ID di sessione noto per ottenere accesso non autorizzato all\u0027account dell\u0027utente.","severity":"medio","solution":"Per prevenire gli attacchi di Session Fixation, è necessario rigenerare l\u0027ID di sessione dopo l\u0027autenticazione o il cambio di utente. È possibile utilizzare funzioni o librerie specifiche per il linguaggio di programmazione utilizzato per generare un nuovo ID di sessione univoco e associarlo all\u0027account dell\u0027utente.","exampleSolutionCode":"cookie[\u0027SESSIONID\u0027] \u003d session","fileName":"attacks.py"},{"name":"Session Hijacking","description":"La vulnerabilità di Session Hijacking si verifica quando un attaccante riesce a ottenere o indovinare l\u0027ID di sessione di un utente legittimo. Ciò consente all\u0027attaccante di impersonare l\u0027utente e ottenere accesso non autorizzato all\u0027account dell\u0027utente.","severity":"medio","solution":"Per prevenire gli attacchi di Session Hijacking, è necessario utilizzare tecniche di gestione delle sessioni sicure, come l\u0027utilizzo di ID di sessione casuali, la scadenza delle sessioni dopo un periodo di inattività o l\u0027utilizzo di token di autenticazione per verificare l\u0027identità dell\u0027utente ad ogni richiesta.","exampleSolutionCode":"cursor.execute(\"SELECT * FROM users WHERE session \u003d ?\", [session])","fileName":"attacks.py"},{"name":"Auth Bypass","description":"La vulnerabilità di Auth Bypass si verifica quando un\u0027applicazione web non verifica correttamente l\u0027autenticazione o l\u0027autorizzazione dell\u0027utente prima di eseguire azioni sensibili. Ciò consente a un attaccante di eseguire azioni non autorizzate o ottenere informazioni sensibili.","severity":"medio","solution":"Per prevenire gli attacchi di Auth Bypass, è necessario verificare l\u0027autenticazione o l\u0027autorizzazione dell\u0027utente prima di eseguire azioni sensibili. È possibile utilizzare sessioni, token di autenticazione o altre forme di autenticazione per garantire che solo gli utenti autorizzati possano eseguire tali azioni.","exampleSolutionCode":"if user:\n    content \u003d content.format(type\u003dtype, message\u003dmessage)\n    cursor.execute(\"UPDATE users SET session \u003d ? WHERE id \u003d ?\", (session, user[0]))","fileName":"attacks.py"},{"name":"XS Request Forgery","description":"La vulnerabilità di XS Request Forgery si verifica quando un\u0027applicazione web non verifica correttamente l\u0027origine delle richieste HTTP prima di eseguire azioni sensibili. Ciò consente a un attaccante di eseguire azioni non autorizzate a nome dell\u0027utente.","severity":"medio","solution":"Per prevenire gli attacchi di XS Request Forgery, è necessario utilizzare token CSRF (Cross-Site Request Forgery) per verificare l\u0027origine delle richieste HTTP. È possibile generare e includere un token CSRF univoco in ogni modulo o richiesta che esegue azioni sensibili e verificare il token al momento dell\u0027elaborazione della richiesta.","exampleSolutionCode":"if \u0027email\u0027 in params.keys():\n    cursor.execute(\"UPDATE users SET email \u003d ? WHERE id \u003d ?\", (email, user[0]))","fileName":"attacks.py"},{"name":"Clickjacking","description":"La vulnerabilità di Clickjacking si verifica quando un\u0027applicazione web viene incorporata in un\u0027altra pagina web in modo nascosto o ingannevole, consentendo all\u0027attaccante di ingannare l\u0027utente e farlo eseguire azioni non desiderate o rivelare informazioni sensibili.","severity":"medio","solution":"Per prevenire gli attacchi di Clickjacking, è necessario utilizzare l\u0027intestazione X-Frame-Options per limitare l\u0027incorporamento del sito web in altre pagine. È possibile impostare l\u0027intestazione X-Frame-Options su \u0027DENY\u0027 per impedire completamente l\u0027incorporamento o su \u0027SAMEORIGIN\u0027 per consentire solo l\u0027incorporamento all\u0027interno dello stesso dominio.","exampleSolutionCode":"content \u003d \u0027\u0027\u0027\n\u003cdiv class\u003d\"alert alert-danger\"\u003e\n    Irreversible and destructive actions!\n\u003c/div\u003e\n\u003cform method\u003d\"GET\" action\u003d\"/danger\"\u003e\n    \u003cdiv class\u003d\"form-group\"\u003e\n        \u003clabel\u003e\n            Delete this account\n        \u003c/label\u003e\n        \u003csmall style\u003d\"margin-top:-10px\" class\u003d\"form-text text-muted\"\u003e\n            Once you delete your account, there is no going back. Please be certain.\n        \u003c/small\u003e\n        \u003cinput type\u003d\"hidden\" name\u003d\"delete\" value\u003d\"1\"\u003e\n        \u003cbutton class\u003d\"btn btn-danger\" type\u003d\"submit\" style\u003d\"float:right;margin-top:-40px\"\u003eDelete\u003c/button\u003e\n    \u003c/div\u003e\n\u003c/form\u003e\n\u0027\u0027\u0027","fileName":"attacks.py"},{"name":"Command Injection","description":"Il codice contiene una vulnerabilità di Command Injection. L\u0027input dell\u0027utente viene utilizzato direttamente in una chiamata subprocess.check_output senza essere opportunamente sanificato o validato.","severity":"serio","solution":"Per risolvere questa vulnerabilità, è necessario validare e sanificare l\u0027input dell\u0027utente prima di utilizzarlo in una chiamata subprocess. È possibile utilizzare la funzione shlex.quote() per sanificare l\u0027input dell\u0027utente e assicurarsi che non vengano eseguiti comandi non autorizzati.","exampleSolutionCode":"import shlex\n\ninput \u003d shlex.quote(user_input)\noutput \u003d subprocess.check_output(input, shell\u003dTrue, stderr\u003dsubprocess.STDOUT, stdin\u003dsubprocess.PIPE)","fileName":"handlers.py"},{"name":"Utilizzo di SSLv3","description":"Il codice utilizza SSLv3, che è obsoleto e insicuro.","severity":"serio","solution":"Utilizzare TLS al posto di SSLv3.","exampleSolutionCode":"ctx.options \u0026\u003d ~ssl.OP_NO_SSLv3","fileName":"dsvpwa.py"}]